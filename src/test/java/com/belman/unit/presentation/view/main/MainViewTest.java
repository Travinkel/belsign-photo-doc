package com.belman.unit.presentation.view.main;
// Generated by Qodo Gen

import com.belman.bootstrap.lifecycle.LifecycleManager;
import com.belman.presentation.base.BaseController;
import com.belman.presentation.base.BaseView;
import com.belman.presentation.core.ViewLoader;
import com.belman.presentation.views.main.MainView;
import com.belman.presentation.views.main.MainViewModel;
import com.gluonhq.charm.glisten.application.MobileApplication;
import com.gluonhq.charm.glisten.control.AppBar;
import com.gluonhq.charm.glisten.control.ProgressIndicator;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class MainViewTest {


    @BeforeAll
    static void initJfx() {
        Platform.startup(() -> {
        });
    }

    // Verify MainView extends BaseView with MainViewModel type parameter
    @Test
    public void test_main_view_extends_base_view_with_main_view_model() {
        MainView mainView = new MainView();

        assertNotNull(mainView);
        assertInstanceOf(BaseView.class, mainView);

        // Verify the generic type parameter using reflection
        Type genericSuperclass = mainView.getClass().getGenericSuperclass();
        assertInstanceOf(ParameterizedType.class, genericSuperclass);

        ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;
        Type[] typeArguments = parameterizedType.getActualTypeArguments();

        assertEquals(1, typeArguments.length);
        assertEquals(MainViewModel.class, typeArguments[0]);
    }

    // Confirm MainView constructor initializes parent BaseView correctly
    @Test
    public void test_main_view_constructor_initializes_parent_correctly() {
        MainView mainView = new MainView();

        // Verify the view model is properly initialized
        assertNotNull(mainView.getViewModel());
        assertInstanceOf(MainViewModel.class, mainView.getViewModel());

        // Verify the controller is properly initialized
        assertNotNull(mainView.getController());
        assertInstanceOf(BaseController.class, mainView.getController());

        // Verify the view has a center node (loaded from FXML)
        assertNotNull(mainView.getCenter());
    }

    // Check that MainView properly loads its FXML file via ViewLoader
    @Test
    public void test_main_view_loads_fxml_via_view_loader() throws Exception {
        // Use reflection to access the ViewLoader's load method
        Method loadMethod = ViewLoader.class.getDeclaredMethod("load", Class.class);
        loadMethod.setAccessible(true);

        // Create a mock for the LoadedComponents that will be returned
        @SuppressWarnings("unchecked")
        ViewLoader.LoadedComponents<MainViewModel, Object> mockComponents = mock(ViewLoader.LoadedComponents.class);
        BaseController<MainViewModel> mockController = mock(BaseController.class);
        MainViewModel mockViewModel = mock(MainViewModel.class);

        // Configure the mock components
        when(mockComponents.parent()).thenReturn(new javafx.scene.layout.AnchorPane());
        when(mockComponents.controller()).thenReturn(mockController);
        when(mockComponents.viewModel()).thenReturn(mockViewModel);

        // Create a spy on ViewLoader to verify the load method is called
        try (MockedStatic<ViewLoader> viewLoaderMock = mockStatic(ViewLoader.class)) {
            // Configure the mock to return our mock components
            viewLoaderMock.when(() -> ViewLoader.load(eq(MainView.class))).thenReturn(mockComponents);

            // Create a new MainView which should trigger the ViewLoader
            MainView mainView = new MainView();

            // Verify that ViewLoader.load was called with MainView.class
            viewLoaderMock.verify(() -> ViewLoader.load(eq(MainView.class)), times(1));

            // Verify the view was properly initialized with our mock components
            assertNotNull(mainView.getController());
            assertNotNull(mainView.getViewModel());
            assertNotNull(mainView.getCenter());
        }
    }

    // Verify MainView correctly initializes its controller and viewModel
    @Test
    public void test_main_view_initializes_controller_and_view_model() {
        MainView mainView = new MainView();

        // Verify the controller is initialized
        BaseController<?> controller = mainView.getController();
        assertNotNull(controller);

        // Verify the view model is initialized and is of the correct type
        MainViewModel viewModel = mainView.getViewModel();
        assertNotNull(viewModel);

        // Verify the view model is properly connected to the controller
        // Use the getViewModel method instead of accessing the field directly
        Object controllerViewModel = controller.getViewModel();
        assertNotNull(controllerViewModel, "Controller's getViewModel() should not return null");
        assertSame(viewModel, controllerViewModel,
                "Controller's viewModel should be the same instance as the view's viewModel");
    }

    // Verify lifecycle methods (onShow, onHide) are properly called
    @Test
    public void test_lifecycle_methods_are_properly_called() {
        // Create a spy on MainView to track method calls
        MainView mainView = spy(new MainView());
        MainViewModel viewModel = spy(mainView.getViewModel());

        // Use reflection to set the spied viewModel
        try {
            Field viewModelField = BaseView.class.getDeclaredField("viewModel");
            viewModelField.setAccessible(true);
            viewModelField.set(mainView, viewModel);
        } catch (Exception e) {
            fail("Failed to set viewModel field: " + e.getMessage());
        }

        // Disable LifecycleManager registration for this test
        try (MockedStatic<LifecycleManager> lifecycleMock =
                     mockStatic(LifecycleManager.class)) {

            // Mock the registerView method to do nothing
            lifecycleMock.when(() -> LifecycleManager.registerView(any())).then(invocation -> null);

            // Simulate view showing by using reflection to call the protected onViewShown method
            try {
                Method onViewShownMethod = BaseView.class.getDeclaredMethod("onViewShown");
                onViewShownMethod.setAccessible(true);
                onViewShownMethod.invoke(mainView);
            } catch (Exception e) {
                e.printStackTrace(); // Print the stack trace for debugging
                fail("Failed to call onViewShown method: " + e.getMessage() + ", cause: " +
                     (e.getCause() != null ? e.getCause().getMessage() : "null"));
            }

            // Verify onShow methods were called
            verify(mainView).onShow();
            verify(viewModel).onShow();

            // Simulate view hiding by using reflection to call the protected onViewHidden method
            try {
                Method onViewHiddenMethod = BaseView.class.getDeclaredMethod("onViewHidden");
                onViewHiddenMethod.setAccessible(true);
                onViewHiddenMethod.invoke(mainView);
            } catch (Exception e) {
                fail("Failed to call onViewHidden method: " + e.getMessage());
            }

            // Verify onHide methods were called
            verify(mainView).onHide();
            verify(viewModel).onHide();
        }
    }

    // Test behavior when ViewLoader fails to load the FXML file
    @Test
    public void test_view_loader_failure_handling() {
        try (MockedStatic<ViewLoader> viewLoaderMock = mockStatic(ViewLoader.class)) {
            // Make ViewLoader.load throw an exception
            IOException ioException = new IOException("FXML missing");
            viewLoaderMock.when(() -> ViewLoader.load(any(Class.class)))
                    .thenThrow(new RuntimeException("Failed to load view", ioException));

            // Creating a new MainView should now throw a RuntimeException
            RuntimeException exception = assertThrows(RuntimeException.class, () -> {
                new MainView();
            });

            // Verify the exception message
            assertTrue(exception.getMessage().contains("Failed to load view"));
            assertInstanceOf(RuntimeException.class, exception.getCause());
            assertInstanceOf(IOException.class, exception.getCause().getCause());
        }
    }

    // Verify handling when MainViewModel is null or improperly initialized
    @Test
    public void test_null_view_model_handling() {
        MainView mainView = new MainView();

        // Use reflection to set viewModel to null
        try {
            Field viewModelField = BaseView.class.getDeclaredField("viewModel");
            viewModelField.setAccessible(true);
            viewModelField.set(mainView, null);
        } catch (Exception e) {
            fail("Failed to set viewModel field: " + e.getMessage());
        }

        // Simulate view showing - should not throw exception even with null viewModel
        assertDoesNotThrow(() -> {
            mainView.onShow();
        });

        // Simulate view hiding - should not throw exception even with null viewModel
        assertDoesNotThrow(() -> {
            mainView.onHide();
        });
    }

    // Test behavior when AppBar is not available
    @Test
    public void test_behavior_when_app_bar_not_available() {
        MainView mainView = new MainView();

        try (MockedStatic<MobileApplication> mobileAppMock = mockStatic(MobileApplication.class)) {
            // Mock MobileApplication to return null for getInstance()
            mobileAppMock.when(MobileApplication::getInstance).thenReturn(null);

            // These operations should not throw exceptions even when AppBar is not available
            assertDoesNotThrow(() -> {
                mainView.setTitle("Test Title");
                mainView.setShowBackButton(true);
                mainView.setShowMenuButton(true);
            });

            // Now mock MobileApplication to return a mock instance that returns null for getAppBar()
            MobileApplication mockApp = mock(MobileApplication.class);
            when(mockApp.getAppBar()).thenReturn(null);
            mobileAppMock.when(MobileApplication::getInstance).thenReturn(mockApp);

            // These operations should still not throw exceptions
            assertDoesNotThrow(() -> {
                mainView.setTitle("Another Test Title");
                mainView.setShowBackButton(false);
                mainView.setShowMenuButton(false);
            });
        }
    }

    // Check MainView behavior when parent constructor throws exceptions
    @Test
    public void test_parent_constructor_exception_handling() {
        try (MockedStatic<ViewLoader> viewLoaderMock = mockStatic(ViewLoader.class)) {
            // Make ViewLoader.load throw a specific exception
            NullPointerException npe = new NullPointerException("Controller not found");
            viewLoaderMock.when(() -> ViewLoader.load(any(Class.class))).thenThrow(npe);

            // Creating a new MainView should wrap the exception in a RuntimeException
            RuntimeException exception = assertThrows(RuntimeException.class, () -> {
                new MainView();
            });

            // Verify the exception details
            assertEquals("Failed to load view: MainView", exception.getMessage());
            assertSame(npe, exception.getCause());
        }
    }

    // Test MainView with missing or invalid FXML resources
    @Test
    public void test_missing_or_invalid_fxml_resources() {
        try (MockedStatic<ViewLoader> viewLoaderMock = mockStatic(ViewLoader.class)) {
            // Simulate different FXML resource errors

            // 1. Missing FXML file
            FileNotFoundException missingFile = new FileNotFoundException("MainView.fxml not found");
            RuntimeException wrappedException = new RuntimeException("Failed to load view: MainView", missingFile);
            viewLoaderMock.when(() -> ViewLoader.load(eq(MainView.class))).thenThrow(wrappedException);

            RuntimeException exception1 = assertThrows(RuntimeException.class, MainView::new);
            assertEquals("Failed to load view: MainView", exception1.getMessage());
            assertInstanceOf(RuntimeException.class, exception1.getCause(), "Cause should be RuntimeException");
            assertInstanceOf(FileNotFoundException.class, exception1.getCause().getCause(),
                    "Cause of cause should be FileNotFoundException");

            // 2. Invalid FXML content
            IOException invalidContent = new IOException("Invalid FXML content");
            RuntimeException wrappedException2 = new RuntimeException("Failed to load view: MainView", invalidContent);
            viewLoaderMock.when(() -> ViewLoader.load(eq(MainView.class))).thenThrow(wrappedException2);

            RuntimeException exception2 = assertThrows(RuntimeException.class, MainView::new);
            assertEquals("Failed to load view: MainView", exception2.getMessage());
            assertInstanceOf(RuntimeException.class, exception2.getCause(), "Cause should be RuntimeException");
            assertInstanceOf(IOException.class, exception2.getCause().getCause(),
                    "Cause of cause should be IOException");
        }
    }

    // Verify AppBar configuration (title, back button, menu button)
    @Test
    public void test_app_bar_configuration() {
        MainView mainView = new MainView();

        // Mock MobileApplication and AppBar
        MobileApplication mockApp = mock(MobileApplication.class);
        AppBar mockAppBar = mock(AppBar.class);
        when(mockApp.getAppBar()).thenReturn(mockAppBar);

        try (MockedStatic<MobileApplication> mobileAppMock = mockStatic(MobileApplication.class)) {
            mobileAppMock.when(MobileApplication::getInstance).thenReturn(mockApp);

            // Test title setting
            mainView.setTitle("Test Title");
            assertEquals("Test Title", mainView.getTitle());
            verify(mockAppBar).setTitleText("Test Title");

            // Test back button
            mainView.setShowBackButton(true);
            assertTrue(mainView.isShowBackButton());
            verify(mockAppBar, atLeastOnce()).setNavIcon(any());

            // Reset for next verification
            reset(mockAppBar);

            // Test menu button
            when(mockAppBar.getActionItems()).thenReturn(FXCollections.observableArrayList());
            mainView.setShowMenuButton(true);
            assertTrue(mainView.isShowMenuButton());
            verify(mockAppBar, atLeastOnce()).getActionItems();
        }
    }

    // Test loading indicator functionality (show/hide)
    @Test
    public void test_loading_indicator_functionality() {
        MainView mainView = new MainView();

        // Get the children of the view before showing the loading indicator
        int initialChildCount = mainView.getChildren().size();

        // Show loading indicator
        mainView.showLoading();

        // Verify loading indicator was added
        assertEquals(initialChildCount + 1, mainView.getChildren().size());

        // Get the loading indicator using reflection
        ProgressIndicator loadingIndicator = null;
        try {
            Field field = BaseView.class.getDeclaredField("loadingIndicator");
            field.setAccessible(true);
            loadingIndicator = (ProgressIndicator) field.get(mainView);
            assertTrue(loadingIndicator.isVisible());
        } catch (Exception e) {
            fail("Failed to access loadingIndicator field: " + e.getMessage());
        }

        // Hide loading indicator
        mainView.hideLoading();

        // Verify loading indicator is hidden but still in the scene graph
        assertFalse(loadingIndicator.isVisible());
        assertEquals(initialChildCount + 1, mainView.getChildren().size());

        // Show loading again - should not add another indicator
        mainView.showLoading();
        assertEquals(initialChildCount + 1, mainView.getChildren().size());
        assertTrue(loadingIndicator.isVisible());
    }
}
